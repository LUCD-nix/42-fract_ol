#include "fract_ol.h"

double	mandelbrot_inner(double x0, double y0)
{
	double	x;
	double	y;
	double	xtemp;
	double	nu;
	double	res;
	double	z2;
	int		i;

	x = 0;
	y = 0;
	i = -1;
	z2 = x0 * x0 + y0 * y0;
	// skip computation inside M1 - https://iquilezles.org/articles/mset1bulb
	if (256.0 *z2 * z2 - 96.0 * z2 + 32.0 * x0 - 3.0 < 0.0 )
		return (0.0);
	// skip computation inside M2 - https://iquilezles.org/articles/mset2bulb
	if (16.0 * (z2 + 2.0* x0 + 1.0) - 1.0 < 0.0 )
		return (0.0);

		
	while (x * x + y * y <= BAILOUT && ++i < MAX_ITER)
	{
		xtemp = x * x - y * y + x0;
		y = (x + x) * y + y0;
		x = xtemp;
	}
	if (i < MAX_ITER)
	{
		// It is fortuitous that we can use log base 2 here
		// it just so happens that we're interested in 
		// complex args between 0 and 2 (inner log)
		// and that P in f(z) = z**P + c is also 2 (outer log)
		// (see wikipedia for reference)
		// either way, it should be the fast
		nu = log2(log2(x * x + y * y)) + 4.0;
		res = i + 1 - nu;
	}
	else
		res = (double)i;
	return (res);
}
int	interpolate_rgb(int colour1, int colour2, double frac)
{
	int	red1;
	int	green1;
	int	blue1;
	int	red2;
	int	green2;
	int	blue2;
	int	res;

	red1 = colour1 >> 16 & 0xFF;
	green1 = colour1 >> 8 & 0xFF;
	blue1 = colour1 & 0xFF;
	red2 = colour2 >> 16 & 0xFF;
	green2 = colour2 >> 8 & 0xFF;
	blue2 = colour2 & 0xFF;
	res = 0;
	res += (int)(red1 + frac * (red2 - red1)) << 16;
	res += (int)(green1 + frac * (green2 - green1)) << 8;
	res += (int)(blue1 + frac * (blue2 - blue1));
	return (res);
}

// TODO: create a practical colouring function, base on https://www.shadertoy.com/view/4df3Rn
void	colour_and_put(t_data *img, double iter, int px, int py)
{
	int	palette[400] = { 0x000003, 0x000005, 0x000008, 0x01000A, 0x01000D, 0x01000F, 0x020112, 0x020114, 0x030117, 0x040119, 0x04011C, 0x05011E, 0x060121, 0x070123, 0x080126, 0x0A0128, 0x0B012B, 0x0C022D, 0x0E0230, 0x0F0232, 0x110235, 0x120237, 0x14023A, 0x16023C, 0x18023F, 0x1A0241, 0x1C0344, 0x1E0346, 0x200348, 0x22034B, 0x24034D, 0x270350, 0x290352, 0x2C0455, 0x2E0457, 0x31045A, 0x34045C, 0x37045E, 0x390461, 0x3C0563, 0x3F0566, 0x430568, 0x46056A, 0x49056D, 0x4C066F, 0x500672, 0x530674, 0x560676, 0x5A0679, 0x5E077B, 0x61077E, 0x650780, 0x690782, 0x6D0785, 0x710887, 0x75088A, 0x79088C, 0x7D088E, 0x810991, 0x860993, 0x8A0995, 0x8E0998, 0x93099A, 0x970A9C, 0x9C0A9F, 0xA10AA1, 0xA30BA1, 0xA60BA1, 0xA80BA1, 0xAA0BA1, 0xAD0CA1, 0xAF0CA0, 0xB10CA0, 0xB40C9F, 0xB60D9F, 0xB80D9E, 0xBB0D9D, 0xBD0E9C, 0xBF0E9C, 0xC20E9B, 0xC40E9A, 0xC60F99, 0xC80F98, 0xCB0F96, 0xCD1095, 0xCF1094, 0xD21092, 0xD41191, 0xD61190, 0xD8118E, 0xDB128C, 0xDD128B, 0xDF1289, 0xE11387, 0xE41385, 0xE61383, 0xE81482, 0xEA147F, 0xED147D, 0xEF157B, 0xF11579, 0xF11777, 0xF21875, 0xF21A73, 0xF21C71, 0xF31D6F, 0xF31F6D, 0xF3216B, 0xF42269, 0xF42468, 0xF42666, 0xF42764, 0xF52963, 0xF52B61, 0xF52D60, 0xF62E5E, 0xF6305D, 0xF6325B, 0xF6335A, 0xF73558, 0xF73757, 0xF73956, 0xF83A55, 0xF83C53, 0xF83E52, 0xF83F51, 0xF84150, 0xF9434F, 0xF9454E, 0xF9464D, 0xF9484D, 0xFA4A4C, 0xFA4C4C, 0xFA514D, 0xFA554F, 0xFB5951, 0xFB5D53, 0xFB6155, 0xFB6556, 0xFB6958, 0xFC6D5A, 0xFC715C, 0xFC755E, 0xFC795F, 0xFC7C61, 0xFC8063, 0xFD8465, 0xFD8767, 0xFD8B68, 0xFD8F6A, 0xFD926C, 0xFD966E, 0xFE9970, 0xFE9C72, 0xFEA073, 0xFEA375, 0xFEA677, 0xFEA979, 0xFEAC7B, 0xFFAF7D, 0xFFB27F, 0xFFB580, 0xFFB882, 0xFFBB84, 0xFFBE86, 0xFFC188, 0xFFC48A, 0xFFC68C, 0xFFC98E, 0xFFCB8F, 0xFFCE91, 0xFFD093, 0xFFD395, 0xFFD597, 0xFFD799, 0xFFDA9B, 0xFFDC9D, 0xFFDE9F, 0xFFE0A1, 0xFFE2A3, 0xFFE4A4, 0xFFE6A6, 0xFFE8A8, 0xFFEAAA, 0xFFEBAC, 0xFFEDAE, 0xFFEFB0, 0xFFF0B2, 0xFFF2B4, 0xFFF3B6, 0xFFF5B8, 0xFFF6BA, 0xFFF7BC, 0xFFF9BE, 0xFFFAC0, 0xFFFBC2, 0xFFFCC4, 0xFFFDC6, 0xFFFEC8, 0xFFFFCA, 0xFFFFCC, 0xFFFFCA, 0xFFFEC8, 0xFFFDC6, 0xFFFCC4, 0xFFFBC2, 0xFFFAC0, 0xFFF9BE, 0xFFF7BC, 0xFFF6BA, 0xFFF5B8, 0xFFF3B6, 0xFFF2B4, 0xFFF0B2, 0xFFEFB0, 0xFFEDAE, 0xFFEBAC, 0xFFEAAA, 0xFFE8A8, 0xFFE6A6, 0xFFE4A4, 0xFFE2A3, 0xFFE0A1, 0xFFDE9F, 0xFFDC9D, 0xFFDA9B, 0xFFD799, 0xFFD597, 0xFFD395, 0xFFD093, 0xFFCE91, 0xFFCB8F, 0xFFC98E, 0xFFC68C, 0xFFC48A, 0xFFC188, 0xFFBE86, 0xFFBB84, 0xFFB882, 0xFFB580, 0xFFB27F, 0xFFAF7D, 0xFEAC7B, 0xFEA979, 0xFEA677, 0xFEA375, 0xFEA073, 0xFE9C72, 0xFE9970, 0xFD966E, 0xFD926C, 0xFD8F6A, 0xFD8B68, 0xFD8767, 0xFD8465, 0xFC8063, 0xFC7C61, 0xFC795F, 0xFC755E, 0xFC715C, 0xFC6D5A, 0xFB6958, 0xFB6556, 0xFB6155, 0xFB5D53, 0xFB5951, 0xFA554F, 0xFA514D, 0xFA4C4C, 0xFA4A4C, 0xF9484D, 0xF9464D, 0xF9454E, 0xF9434F, 0xF84150, 0xF83F51, 0xF83E52, 0xF83C53, 0xF83A55, 0xF73956, 0xF73757, 0xF73558, 0xF6335A, 0xF6325B, 0xF6305D, 0xF62E5E, 0xF52D60, 0xF52B61, 0xF52963, 0xF42764, 0xF42666, 0xF42468, 0xF42269, 0xF3216B, 0xF31F6D, 0xF31D6F, 0xF21C71, 0xF21A73, 0xF21875, 0xF11777, 0xF11579, 0xEF157B, 0xED147D, 0xEA147F, 0xE81482, 0xE61383, 0xE41385, 0xE11387, 0xDF1289, 0xDD128B, 0xDB128C, 0xD8118E, 0xD61190, 0xD41191, 0xD21092, 0xCF1094, 0xCD1095, 0xCB0F96, 0xC80F98, 0xC60F99, 0xC40E9A, 0xC20E9B, 0xBF0E9C, 0xBD0E9C, 0xBB0D9D, 0xB80D9E, 0xB60D9F, 0xB40C9F, 0xB10CA0, 0xAF0CA0, 0xAD0CA1, 0xAA0BA1, 0xA80BA1, 0xA60BA1, 0xA30BA1, 0xA10AA1, 0x9C0A9F, 0x970A9C, 0x93099A, 0x8E0998, 0x8A0995, 0x860993, 0x810991, 0x7D088E, 0x79088C, 0x75088A, 0x710887, 0x6D0785, 0x690782, 0x650780, 0x61077E, 0x5E077B, 0x5A0679, 0x560676, 0x530674, 0x500672, 0x4C066F, 0x49056D, 0x46056A, 0x430568, 0x3F0566, 0x3C0563, 0x390461, 0x37045E, 0x34045C, 0x31045A, 0x2E0457, 0x2C0455, 0x290352, 0x270350, 0x24034D, 0x22034B, 0x200348, 0x1E0346, 0x1C0344, 0x1A0241, 0x18023F, 0x16023C, 0x14023A, 0x120237, 0x110235, 0x0F0232, 0x0E0230, 0x0C022D, 0x0B012B, 0x0A0128, 0x080126, 0x070123, 0x060121, 0x05011E, 0x04011C, 0x040119, 0x030117, 0x020114, 0x020112, 0x01000F, 0x01000D, 0x01000A, 0x000008, 0x00000
 };
	int	colour1;
	int	colour2;
	int	colour;

	colour1 = palette[(int)floor(iter) % 400];
	colour2 = palette[(int)ceil(iter) % 400];
	colour = interpolate_rgb(colour1, colour2, fmod(iter, 1));
	put_pixel_to_img(img, px, py, colour);
}

double	get_x_coord(int px, t_data *img)
{
	double res;

	(void) img;
	res = (double)px / 1920.0 * 3.5 - 2.5;
	return (res);
}

// TODO : use img to properly scale the points, also rotation is wrong
double	get_y_coord(int py, t_data *img)
{
	double res;

	(void) img;
	res = (double)py / 1080.0 * 2.0 - 1;
	return (res);
}

void	mandelbrot(t_data *img, int max_x, int max_y)
{
	int		px;
	int		py;
	double	iter;
	double	x0;
	double	y0;

	py = 0;
	while (py < max_y)
	{
		px = 0;
		y0 = get_y_coord(py, img);
		while (px < max_x)
		{
			x0 = get_x_coord(px, img);
			iter = mandelbrot_inner(x0, y0);
			colour_and_put(img, iter, px, py);
			px++;
		}
		py++;
	}
}
